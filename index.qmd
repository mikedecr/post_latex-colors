
---
author: Michael DeCrescenzo
categories: [code, latex]
title: |
    Treating $\mathrm{\LaTeX}$ like a programming language:
    the case of color-coded equations
# subtitle: | "That's it. Every blog post gets its own repository" and other adventures
# excerpt: |
#     A blogdown website is more like a combination of modular components that are better managed independently, each component with its own repository.
#     These modular components _come together_ at the nexus of the website, but the components do not _belong to_ the website.
date: "2022-08-31"
knitr:
    opts_chunk:
        collapse: true
        eval: false
draft: false
image: "eq.png"
---

$\newcommand{latex}{\mathrm{\LaTeX}}$

$\latex$ can be a headache.
The syntax is clunky.
Normal usage leads us to engage with a lot of frustrating patterns.
I see academics and other researchers complain about it, and I usually agree with where these complaints are coming from.

But I also feel like many researchers don't get the most out of $\latex$.
When I used to write more $\latex$ in graduate school, I knew I didn't.
I mean, I was _good_ at algorithmically injecting my statistical results into documents, managing citations and cross-references, and so on.
But the shoeleather work of $\latex$---writing the boilerplate code to itemize and enumerate, control environments, typeset math---wasn't something I was equipped to criticize very confidently.
I would end up repeating myself a lot in my code, getting trapped inside of irritating design patterns, and feeling the _age_ of the language constantly.

But you get older, you (hopefully) get better at programming, and you realize what you were being silly about.

This blog post is about how _$\mathit{\LaTeX}$ is a programming language_.
You can do ordinary programming language things with it, like save variables and write functions.
And then you can turn those variables and functions into interfaces that let you work with greater efficiency.
And you can design those interfaces to make your work more joyful.

Thinking about programming challenges in $\latex$ has been [on my mind](https://twitter.com/mikedecr/status/1559721156130881536) for a little while,
but I worked up a quick example when [Jordan Nafa was talking about color-coding different parts of some equations](https://twitter.com/adamjnafa/status/1565164364981620737).
So that will be our example for this post: **color-coding an equation**.
This will not require deep $\latex$ expertise, knowledge of external packages, or other complicated tricks.
We only have to a little ordinary programming thinking to turn $\latex$'s built-in color tools into something more practical and friendly.


## Color fundamentals in $\latex$

Like many things in $\latex$, the built-in experience of color-control is a little clunky.
You change your text color with `\color{}`, and naturally you pass some color argument.
The language provides a few builtin keywords like `red` and `blue`, which are harsh, but others like `violet`, `teal`, and `maroon` are fine.
But the color options aren't the problem.
The problem is the interface, which works like this.

Any time you change a color, you change it _indefinitely_, at least up until there is a scope change that bounds the application of the new color.
Here is an example:

```{latex}
We start with some normal text.
\color{red} And now the text is red indefinitely.
```

We can render this in the browser:[^mathtext]

[^mathtext]: This is done by calling a `\text{}` environment within the math environment provided by MathJax or KaTeX or whichever I am running on this website...

$$
\text{
    We start with some normal text. 
    \color{red} And now the text is red indefinitely.
}
$$


You may have encountered similar behavior with altering text _size_.

```{latex}
We start with some normal text.
\huge And now the text is huge indefinitely.
```

$$
\text{
    We start with some normal text. 
    \huge And now the text is huge indefinitely.
}
$$

We can extert some control over the "indefinite" application of these settings by introducing some scope, for instance with curly braces.

```{latex}
We start with some normal text. 
{ \color{red} But the } redness is { \color{red} contained }.
```

$$
\text{
    We start with some normal text. 
    {\color{red} But the} redness is {\color{red} contained}.
}
$$

This isn't _the worst_ but it doesn't feel too comfortable.
It would feel better to control colors more like this:
```latex
\red{But the} redness is \red{contained}
```
which not only saves keystrokes but makes the whole experience feel more function-oriented and declarative.
We will work toward something that feels similar (not identical) to this.


## Doing better, with an equation example

Let's say we have an equation that has certain terms that we want to apply colors to.
More specifically, we want to _map_ certain semantic features of the equation's meaning to specific colors in a consistent way.
We would like the interface to be minimally burdensome. I don't want to have to type (or _think_) too much to get good effects.

Let's meet our equation and its "semantics".
We collect data on some individuals subscripted $i$, who are located within groups $g$, and measured across time units $t$.
We model some outcome $y_{it}$ as varying across individuals within groups and over time,
\begin{align}
    y_{it} &= \alpha + \mu_{i} + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it}
\end{align}
where $\alpha$ is a constant term,
$\mu_{i}$ is a term that is fixed for an individual $i$ across repeated observations,
$\gamma_{g[i]}$ is a group-specific that is fixed across time for all $i$ in group $g$,
$\tau_{t}$ is a time-unit effect that is fixed for all individuals,
and $\varepsilon_{it}$ is random error.
These units of measurement---units, groups, time periods---are the "semantics" that we want to map to colors.

We have already identified one problem: we don't want colors to apply indefinitely.
This means that in order to turn "off" a color, I either have to explicitly call `\color{black}` again,
or I have to scope the color e.g. with curly braces.


```{latex}
% back to black
y_{it} &= \alpha + \color{violet} \mu_{i} \color{black} 
          + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it} \\

% use scope
y_{it} &= \alpha + {\color{violet} \mu_{i}} 
          + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it}
```

\begin{align}
    y_{it} &= \alpha + \color{violet} \mu_{i} \color{black} + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it} \\
    y_{it} &= \alpha + {\color{violet} \mu_{i}} + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it}
\end{align}

Using the curly braces is definitely _safer_ than `\color{black}`; I don't want to assume that we always want to return to `black`.
But managing the curly braces yourself can be cumbersome if you aren't used to writing $\latex$ that way already.
I don't write with that style, so I don't want to burden myself with unusual patterns.[^lisp]

[^lisp]: Although I could totally see, for example, Lisp users feeling quite comfortable with that style.
It feels more like the `(function arg1 arg2)` syntax.

So to improve things, we will introduce a function that, at first, will not feel like much of an improvement.
But we discuss it to highlight both _how_ we can modify interfaces with pretty simple tools and _why_ we may want to do that.
So, consider a function called `setcolor`, which takes two arguments: a color code and the text you want apply the color to locally.

```{latex}
% notice the extra {} braces in the definition
\newcommand{\setcolor}[2]{ {\color{#1} {#2}} } 

% apply function to the equation
y_{it} &= \alpha + \setcolor{violet}{\mu_{i}} 
          + \tau_{t} + \varepsilon_{it}
```

\begin{align}
    \newcommand{\setcolor}[2]{ {\color{#1} {#2}} }
    y_{it} &= \alpha + \setcolor{violet}{\mu_{i}} + \gamma_{g[i]} + \tau_{t} + \varepsilon_{it}
\end{align}

Why do I say that this function may not feel like much of an improvement?
It has _some_ drawbacks: it really isn't any "faster" to type `\setcolor{violet}{\mu_{i}}` than it is to type `{\color{violet} \mu_{i}}`.
It actually has more characters and just as many curly braces.
But it is _better_ in at least two important respects that we should care about when we write code.
One, we made the problem of locally scoping the color _inherent to the function_ instead of being procedurally managed _ad hoc_ outside of the function.
This is good because it makes the whole thing more bug-proof.
It also makes the interface feel more naturally function-like:
we achieve a coherent result by calling a function with a predictable interface, then our work is done.
No managing other special characters in the language as a side concern.
It is easier to remember one thing (use a function) than it is to remember two things (use a function _oh and also manage the weird scope_).
So we get a safer function with a more recognizable interface.
Not so bad!

But we aren't done there.
We complete the interface by using this function to map semantics to colors directly.
We create a function called `\unitfx{}` which applies the same color to any term in the equation that semantically refers to unit-level effects.
Same for a functions called `groupfx{}`, `\timefx{}`, and so on.
We also throw in a generic `\param{}` function for other terms.

```{latex}
\newcommand{unitfx}[1]{\setcolor{violet}{#1}}
\newcommand{groupfx}[1]{\setcolor{green}{#1}}
\newcommand{timefx}[1]{\setcolor{lightblue}{#1}}
\newcommand{param}[1]{\setcolor{maroon}{#1}}
```

So as long as we define these color commands in one place, all the hard work is done.
All downstream calls to these functions are simple.
Just wrap a term in the equation inside of the function corresponding to its semantic.

```{latex}
y_{it} &= \param{\alpha} + \unitfx{\mu_{i}}
          + \groupfx{\gamma_{g[i]}} + \timefx{\tau_{t}}
          + \param{\varepsilon_{it}}
```

\begin{align}
    \newcommand{unitfx}[1]{\setcolor{violet}{#1}}
    \newcommand{groupfx}[1]{\setcolor{green}{#1}}
    \newcommand{timefx}[1]{\setcolor{orange}{#1}}
    \newcommand{param}[1]{\setcolor{maroon}{#1}}
    y_{it} &= \param{\alpha} + \unitfx{\mu_{i}} + \groupfx{\gamma_{g[i]}} + \timefx{\tau_{t}} + \param{\varepsilon_{it}}
\end{align}


## Conclusion

So that's it.
Our solution meaningfully improves the color experience in $\latex$ using just five lines of code: one to create a helper function and four more to create some color mappings.
The helper function let us change the interface to color control in the _general case_.
And the color mappings let us apply the new interface to create simple key-value pairs that map a semantic to a color.
And bonus: the interface is also safer because managing the scope of a color modification requires no more work for the user.

We also do this without introducing any dependencies.
We could still load outside packages to access more color values, but that choice doesn't bear on the general interface or vice-versa.
That modularity is a good design feature.

And all because we thought about a $\latex$ problem like a programming problem.

